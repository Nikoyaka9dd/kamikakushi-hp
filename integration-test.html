<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>çµ±åˆãƒ†ã‚¹ãƒˆã¨å‹•ä½œç¢ºèª - UI Animation Enhancement</title>
    <style>
        body {
            font-family: 'YuGothic', 'Yu Gothic', sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5dc;
            color: #dc143c;
        }
        
        .test-container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        .test-section {
            margin: 30px 0;
            padding: 20px;
            border: 2px solid #dc143c;
            border-radius: 8px;
            background: #fafafa;
        }
        
        .test-section h2 {
            color: #8b0000;
            margin-top: 0;
            border-bottom: 2px solid #dc143c;
            padding-bottom: 10px;
        }
        
        .test-result {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-weight: bold;
        }
        
        .test-pass {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .test-fail {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .test-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        
        .test-info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        .performance-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }
        
        .metric-card {
            background: white;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #ddd;
            text-align: center;
        }
        
        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #8b0000;
        }
        
        .metric-label {
            font-size: 0.9em;
            color: #666;
            margin-top: 5px;
        }
        
        .browser-test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }
        
        .browser-card {
            background: white;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #ddd;
        }
        
        .test-controls {
            margin: 20px 0;
            text-align: center;
        }
        
        .test-button {
            background: #8b0000;
            color: white;
            border: none;
            padding: 12px 24px;
            margin: 5px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.3s;
        }
        
        .test-button:hover {
            background: #a0001a;
        }
        
        .test-button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #dc143c, #8b0000);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .log-container {
            background: #000;
            color: #0f0;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            margin: 15px 0;
        }
        
        .animation-preview {
            border: 2px dashed #dc143c;
            padding: 20px;
            margin: 15px 0;
            text-align: center;
            min-height: 100px;
            position: relative;
            background: #f9f9f9;
        }
        
        .test-iframe {
            width: 100%;
            height: 400px;
            border: 1px solid #ddd;
            border-radius: 6px;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>ğŸ§ª UI Animation Enhancement - çµ±åˆãƒ†ã‚¹ãƒˆã¨å‹•ä½œç¢ºèª</h1>
        
        <div class="test-controls">
            <button class="test-button" onclick="runAllTests()">å…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ</button>
            <button class="test-button" onclick="runAnimationTests()">ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆ</button>
            <button class="test-button" onclick="runPerformanceTests()">ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ</button>
            <button class="test-button" onclick="runCompatibilityTests()">äº’æ›æ€§ãƒ†ã‚¹ãƒˆ</button>
            <button class="test-button" onclick="clearResults()">çµæœã‚¯ãƒªã‚¢</button>
        </div>
        
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        
        <!-- 1. å…¨ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®åŒæ™‚å®Ÿè¡Œãƒ†ã‚¹ãƒˆ -->
        <div class="test-section">
            <h2>ğŸ¬ 1. å…¨ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®åŒæ™‚å®Ÿè¡Œãƒ†ã‚¹ãƒˆ</h2>
            <div id="animationTestResults"></div>
            
            <div class="animation-preview" id="animationPreview">
                <p>ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒªã‚¢</p>
                <iframe src="index.html" class="test-iframe" id="animationIframe"></iframe>
            </div>
            
            <div class="test-controls">
                <button class="test-button" onclick="testSimultaneousAnimations()">åŒæ™‚å®Ÿè¡Œãƒ†ã‚¹ãƒˆ</button>
                <button class="test-button" onclick="testAnimationConflicts()">ç«¶åˆãƒ†ã‚¹ãƒˆ</button>
                <button class="test-button" onclick="testAnimationTiming()">ã‚¿ã‚¤ãƒŸãƒ³ã‚°ãƒ†ã‚¹ãƒˆ</button>
            </div>
        </div>
        
        <!-- 2. ãƒšãƒ¼ã‚¸ãƒªãƒ­ãƒ¼ãƒ‰æ™‚ã®å‹•ä½œç¢ºèªãƒ†ã‚¹ãƒˆ -->
        <div class="test-section">
            <h2>ğŸ”„ 2. ãƒšãƒ¼ã‚¸ãƒªãƒ­ãƒ¼ãƒ‰æ™‚ã®å‹•ä½œç¢ºèªãƒ†ã‚¹ãƒˆ</h2>
            <div id="reloadTestResults"></div>
            
            <div class="test-controls">
                <button class="test-button" onclick="testPageReload()">ãƒªãƒ­ãƒ¼ãƒ‰ãƒ†ã‚¹ãƒˆ</button>
                <button class="test-button" onclick="testCacheHandling()">ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ†ã‚¹ãƒˆ</button>
                <button class="test-button" onclick="testStateReset()">çŠ¶æ…‹ãƒªã‚»ãƒƒãƒˆãƒ†ã‚¹ãƒˆ</button>
            </div>
        </div>
        
        <!-- 3. ç•°ãªã‚‹ãƒ–ãƒ©ã‚¦ã‚¶ã§ã®äº’æ›æ€§ãƒ†ã‚¹ãƒˆ -->
        <div class="test-section">
            <h2>ğŸŒ 3. ãƒ–ãƒ©ã‚¦ã‚¶äº’æ›æ€§ãƒ†ã‚¹ãƒˆ</h2>
            <div id="compatibilityTestResults"></div>
            
            <div class="browser-test-grid" id="browserTestGrid">
                <!-- ãƒ–ãƒ©ã‚¦ã‚¶åˆ¥ãƒ†ã‚¹ãƒˆçµæœãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã‚‹ -->
            </div>
            
            <div class="test-controls">
                <button class="test-button" onclick="testBrowserCompatibility()">äº’æ›æ€§ãƒ†ã‚¹ãƒˆ</button>
                <button class="test-button" onclick="testFeatureSupport()">æ©Ÿèƒ½ã‚µãƒãƒ¼ãƒˆãƒ†ã‚¹ãƒˆ</button>
                <button class="test-button" onclick="testFallbacks()">ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ†ã‚¹ãƒˆ</button>
            </div>
        </div>
        
        <!-- 4. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®šã¨ãƒœãƒˆãƒ«ãƒãƒƒã‚¯ç‰¹å®š -->
        <div class="test-section">
            <h2>âš¡ 4. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®šã¨ãƒœãƒˆãƒ«ãƒãƒƒã‚¯ç‰¹å®š</h2>
            <div id="performanceTestResults"></div>
            
            <div class="performance-metrics" id="performanceMetrics">
                <!-- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æŒ‡æ¨™ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã‚‹ -->
            </div>
            
            <div class="test-controls">
                <button class="test-button" onclick="measurePerformance()">ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®š</button>
                <button class="test-button" onclick="profileAnimations()">ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«</button>
                <button class="test-button" onclick="memoryLeakTest()">ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ãƒ†ã‚¹ãƒˆ</button>
            </div>
        </div>
        
        <!-- ãƒ†ã‚¹ãƒˆãƒ­ã‚° -->
        <div class="test-section">
            <h2>ğŸ“‹ ãƒ†ã‚¹ãƒˆãƒ­ã‚°</h2>
            <div class="log-container" id="testLog"></div>
        </div>
    </div>

    <script>
        // ãƒ†ã‚¹ãƒˆç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 
        class IntegrationTestManager {
            constructor() {
                this.testResults = [];
                this.currentTest = null;
                this.testStartTime = null;
                this.performanceData = {};
                this.logContainer = document.getElementById('testLog');
                this.progressFill = document.getElementById('progressFill');
                this.totalTests = 0;
                this.completedTests = 0;
            }
            
            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = document.createElement('div');
                logEntry.innerHTML = `[${timestamp}] ${type.toUpperCase()}: ${message}`;
                logEntry.style.color = this.getLogColor(type);
                this.logContainer.appendChild(logEntry);
                this.logContainer.scrollTop = this.logContainer.scrollHeight;
                console.log(`[IntegrationTest] ${message}`);
            }
            
            getLogColor(type) {
                const colors = {
                    'info': '#0f0',
                    'success': '#0f0',
                    'warning': '#ff0',
                    'error': '#f00',
                    'debug': '#0ff'
                };
                return colors[type] || '#0f0';
            }
            
            updateProgress() {
                const progress = (this.completedTests / this.totalTests) * 100;
                this.progressFill.style.width = `${progress}%`;
            }
            
            addTestResult(testName, passed, details, duration) {
                this.testResults.push({
                    name: testName,
                    passed: passed,
                    details: details,
                    duration: duration,
                    timestamp: new Date()
                });
                
                this.completedTests++;
                this.updateProgress();
                
                const resultClass = passed ? 'test-pass' : 'test-fail';
                const resultText = passed ? 'PASS' : 'FAIL';
                this.log(`${testName}: ${resultText} (${duration}ms) - ${details}`, passed ? 'success' : 'error');
            }
            
            startTest(testName) {
                this.currentTest = testName;
                this.testStartTime = performance.now();
                this.log(`ãƒ†ã‚¹ãƒˆé–‹å§‹: ${testName}`, 'info');
            }
            
            endTest(passed, details) {
                if (!this.currentTest) return;
                
                const duration = Math.round(performance.now() - this.testStartTime);
                this.addTestResult(this.currentTest, passed, details, duration);
                this.currentTest = null;
                this.testStartTime = null;
            }
            
            displayResults(containerId, results) {
                const container = document.getElementById(containerId);
                container.innerHTML = '';
                
                results.forEach(result => {
                    const resultDiv = document.createElement('div');
                    resultDiv.className = `test-result ${result.passed ? 'test-pass' : 'test-fail'}`;
                    resultDiv.innerHTML = `
                        <strong>${result.name}</strong> - ${result.passed ? 'PASS' : 'FAIL'}<br>
                        <small>${result.details} (å®Ÿè¡Œæ™‚é–“: ${result.duration}ms)</small>
                    `;
                    container.appendChild(resultDiv);
                });
            }
            
            clearResults() {
                this.testResults = [];
                this.completedTests = 0;
                this.totalTests = 0;
                this.updateProgress();
                this.logContainer.innerHTML = '';
                
                // å„çµæœã‚³ãƒ³ãƒ†ãƒŠã‚’ã‚¯ãƒªã‚¢
                ['animationTestResults', 'reloadTestResults', 'compatibilityTestResults', 'performanceTestResults'].forEach(id => {
                    const container = document.getElementById(id);
                    if (container) container.innerHTML = '';
                });
                
                // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æŒ‡æ¨™ã‚’ã‚¯ãƒªã‚¢
                const metricsContainer = document.getElementById('performanceMetrics');
                if (metricsContainer) metricsContainer.innerHTML = '';
                
                this.log('ãƒ†ã‚¹ãƒˆçµæœã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ', 'info');
            }
        }
        
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ†ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
        const testManager = new IntegrationTestManager();
        
        // 1. å…¨ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®åŒæ™‚å®Ÿè¡Œãƒ†ã‚¹ãƒˆ
        async function testSimultaneousAnimations() {
            testManager.startTest('å…¨ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åŒæ™‚å®Ÿè¡Œ');
            
            try {
                // iframeã‹ã‚‰ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚’å–å¾—
                const iframe = document.getElementById('animationIframe');
                const iframeWindow = iframe.contentWindow;
                
                // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¦ç´ ã®å­˜åœ¨ç¢ºèª
                const animationElements = [
                    'mainGif',
                    'cloudLeft', 
                    'cloudRight',
                    'floatingElements'
                ];
                
                let allElementsFound = true;
                const missingElements = [];
                
                animationElements.forEach(elementId => {
                    const element = iframeWindow.document.getElementById(elementId);
                    if (!element) {
                        allElementsFound = false;
                        missingElements.push(elementId);
                    }
                });
                
                if (!allElementsFound) {
                    testManager.endTest(false, `è¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${missingElements.join(', ')}`);
                    return;
                }
                
                // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã®ç¢ºèª
                const animationStatus = iframeWindow.getAnimationStatus ? iframeWindow.getAnimationStatus() : null;
                
                if (animationStatus) {
                    const hasActiveAnimations = Object.values(animationStatus.states).some(state => state === true);
                    testManager.endTest(hasActiveAnimations, `ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³çŠ¶æ…‹: ${JSON.stringify(animationStatus.states)}`);
                } else {
                    testManager.endTest(true, 'ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¦ç´ ãŒæ­£å¸¸ã«é…ç½®ã•ã‚Œã¦ã„ã¾ã™');
                }
                
            } catch (error) {
                testManager.endTest(false, `ã‚¨ãƒ©ãƒ¼: ${error.message}`);
            }
            
            testManager.displayResults('animationTestResults', testManager.testResults.filter(r => r.name.includes('ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³')));
        }
        
        async function testAnimationConflicts() {
            testManager.startTest('ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç«¶åˆãƒ†ã‚¹ãƒˆ');
            
            try {
                const iframe = document.getElementById('animationIframe');
                const iframeWindow = iframe.contentWindow;
                
                // è¤‡æ•°ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’åŒæ™‚ã«é–‹å§‹ã—ã¦ã¿ã‚‹
                if (iframeWindow.AnimationManager) {
                    const initialStates = { ...iframeWindow.AnimationManager.states };
                    
                    // çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¦å†å®Ÿè¡Œ
                    iframeWindow.AnimationManager.resetStates();
                    
                    // è¤‡æ•°ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’åŒæ™‚å®Ÿè¡Œ
                    setTimeout(() => {
                        if (iframeWindow.initMainGifAnimation) iframeWindow.initMainGifAnimation();
                        if (iframeWindow.initCloudAnimations) iframeWindow.initCloudAnimations();
                    }, 100);
                    
                    // 1ç§’å¾Œã«çŠ¶æ…‹ã‚’ç¢ºèª
                    setTimeout(() => {
                        const finalStates = iframeWindow.AnimationManager.states;
                        const hasConflicts = Object.keys(finalStates).some(key => 
                            finalStates[key] !== initialStates[key] && finalStates[key] === 'error'
                        );
                        
                        testManager.endTest(!hasConflicts, `ç«¶åˆæ¤œå‡º: ${hasConflicts ? 'ã‚ã‚Š' : 'ãªã—'}`);
                        testManager.displayResults('animationTestResults', testManager.testResults.filter(r => r.name.includes('ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³')));
                    }, 1000);
                } else {
                    testManager.endTest(false, 'AnimationManagerãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                    testManager.displayResults('animationTestResults', testManager.testResults.filter(r => r.name.includes('ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³')));
                }
                
            } catch (error) {
                testManager.endTest(false, `ã‚¨ãƒ©ãƒ¼: ${error.message}`);
                testManager.displayResults('animationTestResults', testManager.testResults.filter(r => r.name.includes('ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³')));
            }
        }
        
        async function testAnimationTiming() {
            testManager.startTest('ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒŸãƒ³ã‚°ãƒ†ã‚¹ãƒˆ');
            
            try {
                const iframe = document.getElementById('animationIframe');
                const iframeWindow = iframe.contentWindow;
                
                const startTime = performance.now();
                
                // GIFã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
                if (iframeWindow.initMainGifAnimation) {
                    iframeWindow.initMainGifAnimation();
                }
                
                // 1ç§’å¾Œã«é›²ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒé–‹å§‹ã•ã‚Œã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                setTimeout(() => {
                    const cloudLeft = iframeWindow.document.getElementById('cloudLeft');
                    const cloudRight = iframeWindow.document.getElementById('cloudRight');
                    
                    const cloudLeftVisible = cloudLeft && window.getComputedStyle(cloudLeft).opacity > 0;
                    const cloudRightVisible = cloudRight && window.getComputedStyle(cloudRight).opacity > 0;
                    
                    const timingCorrect = cloudLeftVisible || cloudRightVisible;
                    const elapsedTime = Math.round(performance.now() - startTime);
                    
                    testManager.endTest(timingCorrect, `é›²ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°: ${elapsedTime}ms`);
                    testManager.displayResults('animationTestResults', testManager.testResults.filter(r => r.name.includes('ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³')));
                }, 1200); // 1.2ç§’å¾Œã«ãƒã‚§ãƒƒã‚¯ï¼ˆ1ç§’ã®é…å»¶ + ãƒãƒƒãƒ•ã‚¡ï¼‰
                
            } catch (error) {
                testManager.endTest(false, `ã‚¨ãƒ©ãƒ¼: ${error.message}`);
                testManager.displayResults('animationTestResults', testManager.testResults.filter(r => r.name.includes('ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³')));
            }
        }
        
        // 2. ãƒšãƒ¼ã‚¸ãƒªãƒ­ãƒ¼ãƒ‰æ™‚ã®å‹•ä½œç¢ºèªãƒ†ã‚¹ãƒˆ
        async function testPageReload() {
            testManager.startTest('ãƒšãƒ¼ã‚¸ãƒªãƒ­ãƒ¼ãƒ‰ãƒ†ã‚¹ãƒˆ');
            
            try {
                const iframe = document.getElementById('animationIframe');
                const originalSrc = iframe.src;
                
                // iframeã‚’ãƒªãƒ­ãƒ¼ãƒ‰
                iframe.src = '';
                
                setTimeout(() => {
                    iframe.src = originalSrc;
                    
                    // ãƒªãƒ­ãƒ¼ãƒ‰å¾Œã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç¢ºèª
                    setTimeout(() => {
                        const iframeWindow = iframe.contentWindow;
                        const mainGif = iframeWindow.document.getElementById('mainGif');
                        
                        if (mainGif) {
                            const isAnimating = window.getComputedStyle(mainGif).animationName !== 'none';
                            testManager.endTest(isAnimating, `ãƒªãƒ­ãƒ¼ãƒ‰å¾Œã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³: ${isAnimating ? 'æ­£å¸¸' : 'ç•°å¸¸'}`);
                        } else {
                            testManager.endTest(false, 'ãƒ¡ã‚¤ãƒ³GIFè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                        }
                        
                        testManager.displayResults('reloadTestResults', testManager.testResults.filter(r => r.name.includes('ãƒªãƒ­ãƒ¼ãƒ‰')));
                    }, 2000);
                }, 500);
                
            } catch (error) {
                testManager.endTest(false, `ã‚¨ãƒ©ãƒ¼: ${error.message}`);
                testManager.displayResults('reloadTestResults', testManager.testResults.filter(r => r.name.includes('ãƒªãƒ­ãƒ¼ãƒ‰')));
            }
        }
        
        async function testCacheHandling() {
            testManager.startTest('ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ†ã‚¹ãƒˆ');
            
            try {
                // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç„¡åŠ¹åŒ–ã§ã®ãƒªãƒ­ãƒ¼ãƒ‰ãƒ†ã‚¹ãƒˆ
                const iframe = document.getElementById('animationIframe');
                const timestamp = Date.now();
                const originalSrc = iframe.src.split('?')[0];
                
                iframe.src = `${originalSrc}?nocache=${timestamp}`;
                
                setTimeout(() => {
                    const iframeWindow = iframe.contentWindow;
                    const assetsLoaded = iframeWindow.document.images.length > 0;
                    
                    testManager.endTest(assetsLoaded, `ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç„¡åŠ¹åŒ–å¾Œã®èª­ã¿è¾¼ã¿: ${assetsLoaded ? 'æˆåŠŸ' : 'å¤±æ•—'}`);
                    testManager.displayResults('reloadTestResults', testManager.testResults.filter(r => r.name.includes('ãƒªãƒ­ãƒ¼ãƒ‰') || r.name.includes('ã‚­ãƒ£ãƒƒã‚·ãƒ¥')));
                }, 3000);
                
            } catch (error) {
                testManager.endTest(false, `ã‚¨ãƒ©ãƒ¼: ${error.message}`);
                testManager.displayResults('reloadTestResults', testManager.testResults.filter(r => r.name.includes('ãƒªãƒ­ãƒ¼ãƒ‰') || r.name.includes('ã‚­ãƒ£ãƒƒã‚·ãƒ¥')));
            }
        }
        
        async function testStateReset() {
            testManager.startTest('çŠ¶æ…‹ãƒªã‚»ãƒƒãƒˆãƒ†ã‚¹ãƒˆ');
            
            try {
                const iframe = document.getElementById('animationIframe');
                const iframeWindow = iframe.contentWindow;
                
                if (iframeWindow.AnimationManager) {
                    // çŠ¶æ…‹ã‚’å¤‰æ›´
                    iframeWindow.AnimationManager.updateState('mainGifLoaded', true);
                    iframeWindow.AnimationManager.updateState('cloudsAnimated', true);
                    
                    // ãƒªã‚»ãƒƒãƒˆå®Ÿè¡Œ
                    iframeWindow.AnimationManager.resetStates();
                    
                    // ãƒªã‚»ãƒƒãƒˆç¢ºèª
                    const allReset = Object.values(iframeWindow.AnimationManager.states).every(state => state === false);
                    
                    testManager.endTest(allReset, `çŠ¶æ…‹ãƒªã‚»ãƒƒãƒˆ: ${allReset ? 'æˆåŠŸ' : 'å¤±æ•—'}`);
                } else {
                    testManager.endTest(false, 'AnimationManagerãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                }
                
                testManager.displayResults('reloadTestResults', testManager.testResults.filter(r => r.name.includes('ãƒªãƒ­ãƒ¼ãƒ‰') || r.name.includes('çŠ¶æ…‹')));
                
            } catch (error) {
                testManager.endTest(false, `ã‚¨ãƒ©ãƒ¼: ${error.message}`);
                testManager.displayResults('reloadTestResults', testManager.testResults.filter(r => r.name.includes('ãƒªãƒ­ãƒ¼ãƒ‰') || r.name.includes('çŠ¶æ…‹')));
            }
        }
        
        // 3. ãƒ–ãƒ©ã‚¦ã‚¶äº’æ›æ€§ãƒ†ã‚¹ãƒˆ
        async function testBrowserCompatibility() {
            testManager.startTest('ãƒ–ãƒ©ã‚¦ã‚¶äº’æ›æ€§ãƒ†ã‚¹ãƒˆ');
            
            try {
                const iframe = document.getElementById('animationIframe');
                const iframeWindow = iframe.contentWindow;
                
                // ãƒ–ãƒ©ã‚¦ã‚¶æƒ…å ±ã‚’å–å¾—
                const browserInfo = {
                    userAgent: navigator.userAgent,
                    vendor: navigator.vendor,
                    platform: navigator.platform,
                    cookieEnabled: navigator.cookieEnabled,
                    onLine: navigator.onLine,
                    language: navigator.language
                };
                
                // æ©Ÿèƒ½ã‚µãƒãƒ¼ãƒˆç¢ºèª
                const featureSupport = {
                    intersectionObserver: 'IntersectionObserver' in window,
                    cssAnimations: CSS.supports('animation', 'test'),
                    cssTransitions: CSS.supports('transition', 'test'),
                    cssTransforms: CSS.supports('transform', 'translateX(0)'),
                    flexbox: CSS.supports('display', 'flex'),
                    grid: CSS.supports('display', 'grid'),
                    customProperties: CSS.supports('--test', '0'),
                    webp: false // WebP support check would need more complex logic
                };
                
                // äº’æ›æ€§ã‚¹ã‚³ã‚¢è¨ˆç®—
                const supportedFeatures = Object.values(featureSupport).filter(Boolean).length;
                const totalFeatures = Object.keys(featureSupport).length;
                const compatibilityScore = (supportedFeatures / totalFeatures) * 100;
                
                const isCompatible = compatibilityScore >= 80; // 80%ä»¥ä¸Šã§äº’æ›æ€§ã‚ã‚Šã¨åˆ¤å®š
                
                testManager.endTest(isCompatible, `äº’æ›æ€§ã‚¹ã‚³ã‚¢: ${compatibilityScore.toFixed(1)}% (${supportedFeatures}/${totalFeatures})`);
                
                // ãƒ–ãƒ©ã‚¦ã‚¶åˆ¥çµæœè¡¨ç¤º
                this.displayBrowserResults(browserInfo, featureSupport, compatibilityScore);
                
            } catch (error) {
                testManager.endTest(false, `ã‚¨ãƒ©ãƒ¼: ${error.message}`);
            }
            
            testManager.displayResults('compatibilityTestResults', testManager.testResults.filter(r => r.name.includes('äº’æ›æ€§')));
        }
        
        function displayBrowserResults(browserInfo, featureSupport, score) {
            const container = document.getElementById('browserTestGrid');
            
            // ãƒ–ãƒ©ã‚¦ã‚¶åã‚’æ¨å®š
            let browserName = 'Unknown';
            if (browserInfo.userAgent.includes('Chrome')) browserName = 'Chrome';
            else if (browserInfo.userAgent.includes('Firefox')) browserName = 'Firefox';
            else if (browserInfo.userAgent.includes('Safari')) browserName = 'Safari';
            else if (browserInfo.userAgent.includes('Edge')) browserName = 'Edge';
            
            const browserCard = document.createElement('div');
            browserCard.className = 'browser-card';
            browserCard.innerHTML = `
                <h3>${browserName}</h3>
                <div class="metric-value">${score.toFixed(1)}%</div>
                <div class="metric-label">äº’æ›æ€§ã‚¹ã‚³ã‚¢</div>
                <hr>
                <div style="text-align: left; font-size: 0.9em;">
                    ${Object.entries(featureSupport).map(([feature, supported]) => 
                        `<div style="color: ${supported ? 'green' : 'red'}">
                            ${supported ? 'âœ“' : 'âœ—'} ${feature}
                        </div>`
                    ).join('')}
                </div>
            `;
            
            container.appendChild(browserCard);
        }
        
        async function testFeatureSupport() {
            testManager.startTest('æ©Ÿèƒ½ã‚µãƒãƒ¼ãƒˆãƒ†ã‚¹ãƒˆ');
            
            try {
                const iframe = document.getElementById('animationIframe');
                const iframeWindow = iframe.contentWindow;
                
                // å¿…è¦ãªæ©Ÿèƒ½ã®ã‚µãƒãƒ¼ãƒˆçŠ¶æ³ã‚’ãƒã‚§ãƒƒã‚¯
                const criticalFeatures = {
                    'CSS Animations': CSS.supports('animation', 'test'),
                    'CSS Transitions': CSS.supports('transition', 'test'),
                    'CSS Transforms': CSS.supports('transform', 'translateX(0)'),
                    'Intersection Observer': 'IntersectionObserver' in window,
                    'RequestAnimationFrame': 'requestAnimationFrame' in window,
                    'CSS Custom Properties': CSS.supports('--test', '0')
                };
                
                const unsupportedFeatures = Object.entries(criticalFeatures)
                    .filter(([feature, supported]) => !supported)
                    .map(([feature]) => feature);
                
                const allSupported = unsupportedFeatures.length === 0;
                
                testManager.endTest(allSupported, 
                    allSupported ? 'å…¨æ©Ÿèƒ½ã‚µãƒãƒ¼ãƒˆæ¸ˆã¿' : `æœªã‚µãƒãƒ¼ãƒˆæ©Ÿèƒ½: ${unsupportedFeatures.join(', ')}`
                );
                
            } catch (error) {
                testManager.endTest(false, `ã‚¨ãƒ©ãƒ¼: ${error.message}`);
            }
            
            testManager.displayResults('compatibilityTestResults', testManager.testResults.filter(r => r.name.includes('äº’æ›æ€§') || r.name.includes('æ©Ÿèƒ½')));
        }
        
        async function testFallbacks() {
            testManager.startTest('ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ');
            
            try {
                const iframe = document.getElementById('animationIframe');
                const iframeWindow = iframe.contentWindow;
                
                // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿèƒ½ã‚’ãƒ†ã‚¹ãƒˆ
                if (iframeWindow.ErrorHandler) {
                    // æ„å›³çš„ã«ã‚¨ãƒ©ãƒ¼ã‚’ç™ºç”Ÿã•ã›ã¦ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’ãƒ†ã‚¹ãƒˆ
                    const testElement = iframeWindow.document.createElement('img');
                    testElement.src = 'nonexistent-image.jpg';
                    
                    let fallbackTriggered = false;
                    
                    // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚’ãƒ¢ãƒƒã‚¯
                    const originalHandler = iframeWindow.ErrorHandler.handleImageError;
                    iframeWindow.ErrorHandler.handleImageError = function(element, fallback, context) {
                        fallbackTriggered = true;
                        originalHandler.call(this, element, fallback, context);
                    };
                    
                    testElement.onerror = () => {
                        iframeWindow.ErrorHandler.handleImageError(testElement, () => {}, 'test');
                    };
                    
                    // å°‘ã—å¾…ã£ã¦ã‹ã‚‰ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã®å‹•ä½œã‚’ç¢ºèª
                    setTimeout(() => {
                        testManager.endTest(fallbackTriggered, `ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‹•ä½œ: ${fallbackTriggered ? 'æ­£å¸¸' : 'ç•°å¸¸'}`);
                        testManager.displayResults('compatibilityTestResults', testManager.testResults.filter(r => r.name.includes('äº’æ›æ€§') || r.name.includes('ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯')));
                    }, 1000);
                    
                } else {
                    testManager.endTest(false, 'ErrorHandlerãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                    testManager.displayResults('compatibilityTestResults', testManager.testResults.filter(r => r.name.includes('äº’æ›æ€§') || r.name.includes('ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯')));
                }
                
            } catch (error) {
                testManager.endTest(false, `ã‚¨ãƒ©ãƒ¼: ${error.message}`);
                testManager.displayResults('compatibilityTestResults', testManager.testResults.filter(r => r.name.includes('äº’æ›æ€§') || r.name.includes('ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯')));
            }
        }
        
        // 4. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®šã¨ãƒœãƒˆãƒ«ãƒãƒƒã‚¯ç‰¹å®š
        async function measurePerformance() {
            testManager.startTest('ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®š');
            
            try {
                const iframe = document.getElementById('animationIframe');
                const iframeWindow = iframe.contentWindow;
                
                // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®šé–‹å§‹
                const startTime = performance.now();
                let frameCount = 0;
                let lastFrameTime = startTime;
                
                // FPSæ¸¬å®š
                function measureFPS() {
                    const currentTime = performance.now();
                    frameCount++;
                    
                    if (currentTime - lastFrameTime >= 1000) { // 1ç§’é–“éš”
                        const fps = Math.round(frameCount * 1000 / (currentTime - lastFrameTime));
                        testManager.performanceData.fps = fps;
                        frameCount = 0;
                        lastFrameTime = currentTime;
                        
                        // FPSæ¸¬å®šã‚’3ç§’é–“ç¶™ç¶š
                        if (currentTime - startTime < 3000) {
                            requestAnimationFrame(measureFPS);
                        } else {
                            completePerformanceTest();
                        }
                    } else {
                        requestAnimationFrame(measureFPS);
                    }
                }
                
                function completePerformanceTest() {
                    // ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡æ¸¬å®š
                    const memoryInfo = performance.memory ? {
                        used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024),
                        total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024),
                        limit: Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024)
                    } : null;
                    
                    // DOMè¦ç´ æ•°
                    const domElements = iframeWindow.document.querySelectorAll('*').length;
                    
                    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¦ç´ æ•°
                    const animatedElements = iframeWindow.document.querySelectorAll('[style*="animation"], [class*="slide"], [class*="fade"]').length;
                    
                    // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚¹ã‚³ã‚¢è¨ˆç®—
                    let score = 100;
                    if (testManager.performanceData.fps < 30) score -= 30;
                    if (memoryInfo && memoryInfo.used > 50) score -= 20;
                    if (domElements > 200) score -= 10;
                    if (animatedElements > 20) score -= 10;
                    
                    testManager.performanceData = {
                        ...testManager.performanceData,
                        memory: memoryInfo,
                        domElements: domElements,
                        animatedElements: animatedElements,
                        score: Math.max(0, score)
                    };
                    
                    const isGoodPerformance = score >= 70;
                    testManager.endTest(isGoodPerformance, `ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚¹ã‚³ã‚¢: ${score}/100`);
                    
                    // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æŒ‡æ¨™ã‚’è¡¨ç¤º
                    displayPerformanceMetrics();
                    testManager.displayResults('performanceTestResults', testManager.testResults.filter(r => r.name.includes('ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹')));
                }
                
                // FPSæ¸¬å®šé–‹å§‹
                requestAnimationFrame(measureFPS);
                
            } catch (error) {
                testManager.endTest(false, `ã‚¨ãƒ©ãƒ¼: ${error.message}`);
                testManager.displayResults('performanceTestResults', testManager.testResults.filter(r => r.name.includes('ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹')));
            }
        }
        
        function displayPerformanceMetrics() {
            const container = document.getElementById('performanceMetrics');
            const data = testManager.performanceData;
            
            container.innerHTML = `
                <div class="metric-card">
                    <div class="metric-value">${data.fps || 'N/A'}</div>
                    <div class="metric-label">FPS</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">${data.memory ? data.memory.used : 'N/A'}</div>
                    <div class="metric-label">ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ (MB)</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">${data.domElements || 'N/A'}</div>
                    <div class="metric-label">DOMè¦ç´ æ•°</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">${data.animatedElements || 'N/A'}</div>
                    <div class="metric-label">ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¦ç´ æ•°</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">${data.score || 'N/A'}</div>
                    <div class="metric-label">ç·åˆã‚¹ã‚³ã‚¢</div>
                </div>
            `;
        }
        
        async function profileAnimations() {
            testManager.startTest('ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«');
            
            try {
                const iframe = document.getElementById('animationIframe');
                const iframeWindow = iframe.contentWindow;
                
                // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¦ç´ ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚’ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«
                const animatedElements = iframeWindow.document.querySelectorAll('.main-gif, .cloud-image, .fade-in-element, .sakura');
                
                let totalAnimations = animatedElements.length;
                let smoothAnimations = 0;
                
                animatedElements.forEach(element => {
                    const computedStyle = iframeWindow.getComputedStyle(element);
                    const hasWillChange = computedStyle.willChange !== 'auto';
                    const hasTransform3d = computedStyle.transform !== 'none';
                    
                    // ã‚¹ãƒ ãƒ¼ã‚ºãªã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®æ¡ä»¶ã‚’ãƒã‚§ãƒƒã‚¯
                    if (hasWillChange || hasTransform3d) {
                        smoothAnimations++;
                    }
                });
                
                const optimizationRatio = (smoothAnimations / totalAnimations) * 100;
                const isOptimized = optimizationRatio >= 80;
                
                testManager.endTest(isOptimized, `æœ€é©åŒ–ç‡: ${optimizationRatio.toFixed(1)}% (${smoothAnimations}/${totalAnimations})`);
                testManager.displayResults('performanceTestResults', testManager.testResults.filter(r => r.name.includes('ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹') || r.name.includes('ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«')));
                
            } catch (error) {
                testManager.endTest(false, `ã‚¨ãƒ©ãƒ¼: ${error.message}`);
                testManager.displayResults('performanceTestResults', testManager.testResults.filter(r => r.name.includes('ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹') || r.name.includes('ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«')));
            }
        }
        
        async function memoryLeakTest() {
            testManager.startTest('ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ãƒ†ã‚¹ãƒˆ');
            
            try {
                if (!performance.memory) {
                    testManager.endTest(false, 'ãƒ¡ãƒ¢ãƒªæƒ…å ±ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“ï¼ˆChromeä»¥å¤–ã®ãƒ–ãƒ©ã‚¦ã‚¶ï¼‰');
                    testManager.displayResults('performanceTestResults', testManager.testResults.filter(r => r.name.includes('ãƒ¡ãƒ¢ãƒª')));
                    return;
                }
                
                const initialMemory = performance.memory.usedJSHeapSize;
                
                // è¤‡æ•°å›ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã—ã¦ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã‚’ãƒã‚§ãƒƒã‚¯
                const iframe = document.getElementById('animationIframe');
                const iframeWindow = iframe.contentWindow;
                
                for (let i = 0; i < 5; i++) {
                    if (iframeWindow.AnimationManager) {
                        iframeWindow.AnimationManager.resetStates();
                        if (iframeWindow.initMainGifAnimation) iframeWindow.initMainGifAnimation();
                        if (iframeWindow.initCloudAnimations) iframeWindow.initCloudAnimations();
                    }
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
                
                // ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’ä¿ƒã™
                if (window.gc) {
                    window.gc();
                }
                
                setTimeout(() => {
                    const finalMemory = performance.memory.usedJSHeapSize;
                    const memoryIncrease = finalMemory - initialMemory;
                    const memoryIncreaseKB = Math.round(memoryIncrease / 1024);
                    
                    // 1MBä»¥ä¸Šã®å¢—åŠ ã§ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã®å¯èƒ½æ€§
                    const hasMemoryLeak = memoryIncrease > 1024 * 1024;
                    
                    testManager.endTest(!hasMemoryLeak, `ãƒ¡ãƒ¢ãƒªå¢—åŠ : ${memoryIncreaseKB}KB ${hasMemoryLeak ? '(ãƒªãƒ¼ã‚¯ã®å¯èƒ½æ€§)' : '(æ­£å¸¸)'}`);
                    testManager.displayResults('performanceTestResults', testManager.testResults.filter(r => r.name.includes('ãƒ¡ãƒ¢ãƒª')));
                }, 1000);
                
            } catch (error) {
                testManager.endTest(false, `ã‚¨ãƒ©ãƒ¼: ${error.message}`);
                testManager.displayResults('performanceTestResults', testManager.testResults.filter(r => r.name.includes('ãƒ¡ãƒ¢ãƒª')));
            }
        }
        
        // çµ±åˆãƒ†ã‚¹ãƒˆå®Ÿè¡Œé–¢æ•°
        async function runAllTests() {
            testManager.clearResults();
            testManager.totalTests = 12; // å…¨ãƒ†ã‚¹ãƒˆæ•°
            testManager.log('çµ±åˆãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
            
            // é †æ¬¡å®Ÿè¡Œ
            await testSimultaneousAnimations();
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            await testAnimationConflicts();
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            await testAnimationTiming();
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            await testPageReload();
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            await testCacheHandling();
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            await testStateReset();
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            await testBrowserCompatibility();
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            await testFeatureSupport();
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            await testFallbacks();
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            await measurePerformance();
            await new Promise(resolve => setTimeout(resolve, 3000));
            
            await profileAnimations();
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            await memoryLeakTest();
            
            testManager.log('å…¨ãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
        }
        
        async function runAnimationTests() {
            testManager.clearResults();
            testManager.totalTests = 3;
            
            await testSimultaneousAnimations();
            await testAnimationConflicts();
            await testAnimationTiming();
        }
        
        async function runPerformanceTests() {
            testManager.clearResults();
            testManager.totalTests = 3;
            
            await measurePerformance();
            await profileAnimations();
            await memoryLeakTest();
        }
        
        async function runCompatibilityTests() {
            testManager.clearResults();
            testManager.totalTests = 3;
            
            await testBrowserCompatibility();
            await testFeatureSupport();
            await testFallbacks();
        }
        
        function clearResults() {
            testManager.clearResults();
        }
        
        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã®åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', function() {
            testManager.log('çµ±åˆãƒ†ã‚¹ãƒˆã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å®Œäº†', 'info');
            
            // iframeã®èª­ã¿è¾¼ã¿å®Œäº†ã‚’å¾…ã¤
            const iframe = document.getElementById('animationIframe');
            iframe.addEventListener('load', function() {
                testManager.log('ãƒ†ã‚¹ãƒˆå¯¾è±¡ãƒšãƒ¼ã‚¸ã®èª­ã¿è¾¼ã¿å®Œäº†', 'info');
            });
        });
    </script>
</body>
</html>
